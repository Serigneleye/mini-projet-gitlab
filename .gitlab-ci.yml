stages:
  - Lint
  - Compile
  - Security_scan
  - Test
  - Quality
  - Package
  - Review
  - Stop review
  - Staging
  - Production
  - Deployment_validation

variables:
  SONAR_USER_HOME: "${CI_PROJECT_DIR}/.sonar"  # Defines the location of the analysis task cache
  GIT_DEPTH: "0"  # Tells git to fetch all the branches of the project, required by the analysis task
  AMI_ID: "ami-0e2c8caa4b6378d8c"
  KEY_NAME: "deployapp"
  SECURITY_GROUP: "sg-0c452dda561c9c68d"
  INSTANCE_TYPE: "t2.micro"
  STORAGE: 100


flake8:
  image: docker:latest
  stage: Lint
  
  services:
    - docker:dind
  script:
    - apk add --no-cache python3 py3-pip
    - python3 -m venv /path/to/venv
    - . /path/to/venv/bin/activate
    - pip install --upgrade pip setuptools importlib_metadata
    - pip install flake8
    - flake8 --ignore=E501,E303 .

docker_linter:
  image: docker:latest
  stage: Lint
  services:
    - docker:dind
  script:
    - apk add --no-cache wget
    - wget -O /usr/local/bin/hadolint https://github.com/hadolint/hadolint/releases/latest/download/hadolint-Linux-x86_64
    - chmod +x /usr/local/bin/hadolint
    - hadolint Dockerfile

compile:
  image: docker:latest
  stage: Compile
  services:
    - docker:dind
  script:
    - docker build -t gitlabprojet .
    - docker save gitlabprojet > gitlabprojet.tar
  artifacts:
    paths:
      - gitlabprojet.tar

trivy_scan:
  stage: Security_scan
  image: docker:latest
  services:
    - docker:dind
  script:
    - export TRIVY_VERSION=$(wget -qO - "https://api.github.com/repos/aquasecurity/trivy/releases/latest" | grep '"tag_name":' | sed -E 's/.*"v([^"]+)".*/\1/')
    - echo $TRIVY_VERSION
    - wget --no-verbose https://github.com/aquasecurity/trivy/releases/download/v${TRIVY_VERSION}/trivy_${TRIVY_VERSION}_Linux-64bit.tar.gz -O - | tar -zxvf -
    - docker load < gitlabprojet.tar
    - ./trivy image --severity HIGH,CRITICAL --exit-code 1 --no-progress gitlabprojet
 
test:
  stage: Test
  image: docker:latest
  services:
    - docker:dind
  script:
    # Exécuter le fichier test.py à l'intérieur de l'image
    - docker load < gitlabprojet.tar
    - docker run -d -p 80:5000 --env PORT=5000 --name gitlabprojet gitlabprojet python test.py

sonarcloud-check:
  stage: Quality
  image:
    name: sonarsource/sonar-scanner-cli:latest
    entrypoint: [""]
  cache:
    key: "${CI_JOB_NAME}"
    paths:
      - .sonar/cache
  script:
    - sonar-scanner

package:
  stage: Package
  image: docker:latest
  services:
    - docker:dind
  script:
    - docker load < gitlabprojet.tar
    - docker tag gitlabprojet "$CI_REGISTRY_IMAGE:${CI_COMMIT_REF_SLUG}" 
    - docker tag gitlabprojet "$CI_REGISTRY_IMAGE:${CI_COMMIT_SHORT_SHA}"
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" $CI_REGISTRY
    - docker push  "$CI_REGISTRY_IMAGE:${CI_COMMIT_REF_SLUG}"
    - docker push "$CI_REGISTRY_IMAGE:${CI_COMMIT_SHORT_SHA}"


deploy review:
  image: docker:latest
  stage: Review
  services:
    - docker:dind
  #only:
    #- merge_requests
  environment:
    name: review/$CI_COMMIT_REF_SLUG
    url: $REVIEW_ENVIRONMENT_URL
    on_stop: stop review
  script:
    - export INIT_PATH=$(pwd)
    - apk add --no-cache python3 py3-pip
    - python3 -m venv venv  # Créer un environnement virtuel
    - source venv/bin/activate  # Activer l'environnement virtuel
    - pip install awscli  # Installer awscli dans l'environnement virtuel

    - aws configure set aws_access_key_id $AWS_ACCESS_KEY_ID
    - aws configure set aws_secret_access_key $AWS_SECRET_ACCESS_KEY
    - aws configure set region $AWS_DEFAULT_REGION

    - export BRANCH_NAME=$CI_COMMIT_REF_SLUG
    - export TAG="review-$BRANCH_NAME"

    - |
      INSTANCE_ID=$(aws ec2 describe-instances \
        --filters "Name=tag:Name,Values=$TAG" \
        --query "Reservations[*].Instances[*].InstanceId" \
        --output text)

    - |
      if [ -n "$INSTANCE_ID" ]; then
        echo "Une instance avec le tag '$TAG' existe déjà : $INSTANCE_ID"
      else
        USER_DATA="#!/bin/bash
        curl -fsSL https://get.docker.com -o install-docker.sh
        sh install-docker.sh --dry-run
        sudo sh install-docker.sh
        sudo usermod -aG docker ubuntu"

        aws ec2 run-instances \
          --image-id $AMI_ID \
          --count 1 \
          --instance-type $INSTANCE_TYPE \
          --key-name $KEY_NAME \
          --security-group-ids $SECURITY_GROUP \
          --block-device-mappings DeviceName=/dev/sda1,Ebs={VolumeSize=$STORAGE} \
          --tag-specifications 'ResourceType=instance,Tags=[{Key=Name,Value='$TAG'}]' \
          --user-data "$USER_DATA"

        sleep 30
        echo "Instance EC2 créée avec le tag '$TAG'."
      fi

    - |
      PUBLIC_IP=$(aws ec2 describe-instances \
        --filters "Name=tag:Name,Values=$TAG" \
        --query "Reservations[*].Instances[*].PublicIpAddress" \
        --output text)

    - |
      if [ -z "$PUBLIC_IP" ]; then
        echo "Aucune instance trouvée avec le tag '$TAG'."
        exit 1
      fi

    - export HOSTNAME_DEPLOY_REVIEW=$PUBLIC_IP
    - echo "IP publique de l'instance est $HOSTNAME_DEPLOY_REVIEW"

    - apk add openssh-client
    - eval $(ssh-agent -s)
    - mkdir -p ~/.ssh
    - chmod -R 400 ~/.ssh
    - touch ~/.ssh/known_hosts
    - cd ~/.ssh
    - echo "${SSH_KEY}" > id_rsa
    - chmod 0400 id_rsa
    - ssh-keyscan -t rsa  ${HOSTNAME_DEPLOY_REVIEW} >> ~/.ssh/known_hosts
    - command1="docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY"
    - command2="docker pull $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG"
    - command3="docker rm -f gitlabprojet"
    - command4="docker run -d -p 80:5000 --env PORT=5000 --name gitlabprojet $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG"
    - ssh -tt ${SSH_USER}@${HOSTNAME_DEPLOY_REVIEW} 
      -o SendEnv=CI_REGISTRY_IMAGE 
      -o SendEnv=CI_COMMIT_REF_SLUG 
      -o SendEnv=CI_REGISTRY_USER 
      -o SendEnv=CI_REGISTRY_PASSWORD 
      -o SendEnv=CI_REGISTRY 
      -C "$command1 && $command2 && $command3 && $command4"

    - cd $INIT_PATH
    - echo "REVIEW_ENVIRONMENT_URL=http://$HOSTNAME_DEPLOY_REVIEW" >> deploy.env
  artifacts:
    reports:
      dotenv: deploy.env

stop review:
  stage: Stop review
  only:
    - merge_requests
  environment:
    name: review/$CI_COMMIT_REF_SLUG
    action: stop
  when: manual
  script:
    - apk add --no-cache python3 py3-pip
    - python3 -m venv venv  # Créer un environnement virtuel
    - source venv/bin/activate  # Activer l'environnement virtuel
    - pip install awscli  # Installer awscli dans l'environnement virtuel

    - aws configure set aws_access_key_id $AWS_ACCESS_KEY_ID
    - aws configure set aws_secret_access_key $AWS_SECRET_ACCESS_KEY
    - aws configure set region $AWS_DEFAULT_REGION

    - export BRANCH_NAME=$CI_COMMIT_REF_SLUG
    - export TAG="review-$BRANCH_NAME"
    - export NEW_TAG="destroyed-$BRANCH_NAME"

    - |
      INSTANCE_ID=$(aws ec2 describe-instances \
        --filters "Name=tag:Name,Values=$TAG" \
        --query "Reservations[*].Instances[*].InstanceId" \
        --output text)

    - |
      if [ -n "$INSTANCE_ID" ]; then
        echo "Suppression de l'instance avec le tag '$TAG': $INSTANCE_ID"

        # Mettre à jour le tag de l'instance
        aws ec2 create-tags --resources $INSTANCE_ID --tags Key=Name,Value=$NEW_TAG
        echo "Tag de l'instance mis à jour en '$NEW_TAG'."

        echo "Suppression de l'instance avec le tag '$NEW_TAG': $INSTANCE_ID"
        aws ec2 terminate-instances --instance-ids $INSTANCE_ID
        echo "Instance EC2 supprimée avec le tag '$NEW_TAG'."
      else
        echo "Aucune instance avec le tag '$TAG' à supprimer."
      fi
